```
在我的面向对象课程中，有一个图书管理系统的项目，为了测试我实现的代码的正确性，我需要你用python实现一个checker来检查由我的jar包。
关于这个checker，你需要按照如下要求实现：
1. 能询问用户生成多少组测试数据，每组多少条指令。
2. 每一组测试都应当是交互式的：具体的，我们的测试数据点随机给出借书请求，预约请求和查询请求，而还书请求与取书请求依据同学们的输出情况动态生成。即你需要生成一条指令，然后执行被测jar得到对应输出，然后根据输出再生成下一条指令。
3. 对于每次测试的数据点，首先按照题目要求的格式随机初始化图书馆中原有的书目。然后随机生成borrowed，queried，ordered，returned，picked，read，restored七种指令。要求生成returned前必有对应的borrowed，否则生成borrowed；生成picked前必有对应的ordered，否则生成ordered；生成restored前必有对应的read，否则生成read。
4. 生成的每组数据都应当保存至data文件夹下，分别命名为testcase_1, testase_2 ... 
5. 每组数据对应的被测jar的输出都应当保存至output文件夹下，分别命名为output_1, output_2 ...
为了使你更好的理解题目，我会把题目文件(question.md)，题目中依赖的library3(library3.md)和一份该项目的完整实现(realization.md)发给你，你可以根据这个更好理解题目。注意realization.md不保证完全正确。
请在和我交流时使用中文。
```

```
对于jar运行结果错误的定义如下：
1. OPEN和CLOSE指令后，必须输出图书移动的信息，如果没输出则认定为错。
2. 用户输出每次移动图书时，必须检查图书是否在出发地，如果图书不在出发地而被移动了则认定为错。
3. Borrow指令，person只有在满足题目中的借阅限制要求时才能成功，否则失败。如果用户对Borrow指令的处理结果不正确，则认定为错。
```

```
检查用户输出的正确性的标准如下：(以下均以23370001代表借书人)
1. OPEN和CLOSE指令后，必须输出图书移动的信息，如果没输出则认定为错。
2. 每次输出移动图书消息时，必须检查图书是否在出发地，如果图书不在出发地而被移动了则认定为错。
	例如：输出 move C-0007-01 from bs to ao 需要检查C-0007-01这本书是否在bs
3. 如果输出为特定person移动图书的消息时，必须检查图书是否在出发地，如果不在则认定为错。同时还要检查该person是否预约了该书，如果没有则认定为错。
	例如：输出 move C-0007-01 from bs to ao for 23370014 需要检查C-0007-01这本书是否在bs且23370014是否曾经预约过这本书且预约还未失效。
4. 
```

```
一、基本操作的规则符合性错误：
借阅 (borrowed) 错误：
程序接受了对 A 类书的借阅请求。
程序在书架上没有对应 ISBN 的余本时，仍接受了借阅。
程序在学生已持有 B 类书的情况下，仍接受了对另一本 B 类书的借阅。
程序在学生已持有特定 ISBN 的 C 类书的情况下，仍接受了对同一 ISBN 的另一本 C 类书的借阅。
程序接受借阅后，返回的副本号无效、不属于请求的 ISBN，或者该副本原不在书架上。
(可配置) Checker 认为可以借阅，但程序拒绝了（可能为策略差异）。
还书 (returned) 错误：
程序接受了学生归还并非由其持有的书籍。
程序拒绝了学生归还其合法持有的书籍（根据题目，还书应立即成功）。
预约 (ordered) 错误：
程序接受了对 A 类书的预约请求。
程序在学生已有未完成（未取书或未失效）的预约时，仍接受了新的预约请求。
程序在学生已持有 B 类书的情况下，仍接受了对 B 类书的预约。
程序在学生已持有特定 ISBN 的 C 类书的情况下，仍接受了对同一 ISBN 的 C 类书的预约。
(可配置) Checker 认为可以预约，但程序拒绝了。
取书 (picked) 错误：
程序在学生并未预约对应 ISBN 或预约已失效/完成后，仍接受了取书。
程序在预约处没有为该学生预留的对应 ISBN 的书籍（或书籍已逾期拿走）时，仍接受了取书。
程序接受取书后，导致学生违反了借阅数量限制（B类或C类）。
程序接受取书后，返回的副本号无效，或与预约处为该学生预留的书籍副本不符。
(可配置) Checker 认为可以取书，但程序拒绝了。
阅读 (read) 错误：
程序在学生当日已有阅读后未归还的书籍时，仍接受了新的阅读请求。
程序在书架上没有对应 ISBN 的余本时，仍接受了阅读。
程序接受阅读后，返回的副本号无效、不属于请求的 ISBN，或者该副本原不在书架上。
(可配置) Checker 认为可以阅读，但程序拒绝了。
归还 (restored) 错误：
程序接受了学生归还并非由其当前正在阅读的书籍。
程序拒绝了学生归还其正在阅读的书籍（根据题目，阅读归还应立即成功）。
二、图书馆整理流程 (OPEN/CLOSE 时 move 指令) 的一致性错误：
开馆 (OPEN) 整理错误：
move 指令中指定的书籍副本号无效或不存在于图书馆中。
(较宽松检查) move 指令中书籍的起始位置与 Checker 记录的位置不符（考虑到闭馆到开馆间状态的复杂变化，此项检查较宽松）。
开馆整理后，仍有书籍滞留在借还处 (bro)。
开馆整理后，仍有书籍滞留在阅览室 (rr)。
开馆整理后，预约处 (ao) 存在已逾期（根据 Checker 的简化判断）的书籍仍未被移走。
热门书架分配错误：
根据上一开馆周期应成为热门的 ISBN，其在架副本未被移至热门书架 (hbs)。
不应成为热门的 ISBN，其在架副本却出现在热门书架 (hbs)。
move 指令首行输出的不是代表移动条数的数字。
闭馆 (CLOSE) 整理错误：
move 指令中指定的书籍副本号无效。
闭馆整理后，学生仍在阅读（student_reading_books 中记录）且位于阅览室 (rr) 的书籍没有被程序通过 move 指令正确处理（例如移出阅览室）。
三、状态与输出格式错误：
查询 (queried) 输出错误：
对不存在的书籍副本进行查询时的程序行为（Checker 会记录此情况，但具体什么是“错误”取决于题目对这种情况的定义）。
查询结果的第一行格式不正确（例如，moving trace: k 部分缺失或 k 不是数字）。
查询结果报告的轨迹条数 k 与后续实际输出的轨迹行数不符。
(较宽松检查) Checker 记录的轨迹条数与程序输出的轨迹条数显著不符（可能因策略或记录细节差异导致，故为宽松检查）。
通用输出问题：
程序在执行某个指令后，没有产生任何输出。
Java 程序运行时，其标准错误流 (stderr) 报告了异常或错误信息。
四、Checker 内部逻辑与程序行为的不一致性（提示性）：
在某些情况下，Checker 根据其内部维护的状态和规则推断某个操作应该成功，但程序却拒绝了；或者反之。这类情况会被记录，但不一定会直接标记为“失败”，因为可能涉及到题目未明确规定的、图书馆可以自行决定的策略部分。这种不一致性可以帮助发现 Checker 逻辑的不足或程序中一些不直观的策略。
```
